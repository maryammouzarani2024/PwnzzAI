<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insecure Plugin Design - Pwnzza Shop</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>

    
    {% include 'navbar.html' %}

    <main class="container">
        <h1>Insecure Plugin Design</h1>
        
        <div class="insecure-plugin-content">
            <details class="description-dropdown">
                <summary class="dropdown-title">Description</summary>
                <div class="dropdown-content">
                    <section class="section-box">
                        
                        <p>To illustrate this vulnerability in practice, two demonstrative instances have been developed: one using the open-source model running in the local free, and the other leveraging the commercial GPT-4o Mini model.</p><p>
                           <p> Both instances are configured to use a plugin that contains a SQL injection flaw, allowing users to observe the potential risks firsthand.</p>
                            
                    </section>
                </div>
            </details>
            
            <details class="description-dropdown" open>
                <summary class="dropdown-title">Demonstration</summary>
                <div class="dropdown-content">
                    <section class="section-box">
                    <div style="display: flex; align-items: flex-start; margin-bottom: 20px;">
                        <div style="flex: 1;">
                            <p>At <b>Pwnzza Shop</b>, weâ€™ve decided to use an LLM to chat with our customers, hoopla! ðŸŽ‰</p>
                            <p> The LLM is connected to our database so it can fetch pizza information. You can now ask about the prices of our pizzas. But now weâ€™re asking ourselves: is it secure enough against SQL injection attempts?!</p>       
                        </div>
                        <img style="width: 220px; height: auto; margin-left: 15px; flex-shrink: 0;" src="{{ url_for('static', filename='img/insecure plugin.png') }}" alt="Insecure Plugin Design Diagram" class="demonstration-image">
                    </div>

                <!-- Main demo tabs -->
                <div class="model-tabs">
                    <div class="tab-headers">
                        <div class="tab-header active" data-tab="blenderbot-model">Free Model</div>
                        <div class="tab-header" data-tab="openai-model">OpenAI Model</div>
                    </div>
                    
                    <!-- BlenderBot Tab Content -->
                    <div class="tab-content active" id="blenderbot-model-tab">
                        <div class="model-implementation-section">
                            
                            <!-- Chat Interface -->
                            <!-- <h3>Pizza Price Assistant Chat (Free)</h3> -->
                            <div class="chat-container">
                                <div id="chat-messages" class="chat-messages">
                                    
                                    
                                </div>
                                <div class="chat-input">
                                    <input type="text" id="user-message" placeholder="Ask about pizza prices..." >
                                    <button id="send-message">Send</button>
                                </div>
                            </div>
                            
                            <!-- Vulnerability Explanation -->
                            <div class="security-vulnerability">
                                <h3><i class="fas "></i> Vulnerability Explanation</h3>
                                <p>This implementation allows the language model to directly execute SQL injection attacks through text-based function calls, you can view the code here:</p>
                                
                                <details class="code-dropdown">
                                    <summary class="code-dropdown-title">View Vulnerable Code </summary>
                                    <pre class="code-snippet"># VULNERABLE: SQL injection through a free model
                                        import sqlite3

                                        def search_pizza_price(pizza_type):
                                            """
                                            VULNERABLE: Uses raw SQL queries - susceptible to SQL injection
                                            """
                                            conn = sqlite3.connect('application/instance/pizza_shop.db')
                                            cursor = conn.cursor()
                                            
                                            # Input processing (commented out in vulnerable version)
                                            pizza = pizza_type.lower() <span style="color: red;"> # No sanitization! </span>
                                            
                                        <span style="color: red;"> #DANGEROUS: Building SQL query with user input without parameterization</span>
                                            <span style="color: red;">query = f"SELECT name, price FROM pizza WHERE LOWER(name) LIKE '%{pizza}%'"</span>
                                            
                                            <span style="color: red;">cursor.execute(query)  # SQL injection occurs here</span>
                                            results = cursor.fetchall()
                                            
                                            if results:
                                                result_lines = []
                                                for row in results:
                                                    result_lines.append(f"{row[0]}: {row[1]}")
                                                return "\n".join(result_lines)
                                            else:
                                                return "No results found"
                                        ......
                                        # System prompt:
                                        system_prompt = """You are a helpful pizza restaurant assistant.
                                                Your job is to help customers find pizza prices using the search_pizza_price function. 
                                                When customers ask about pizza prices, call the search_pizza_price function with the pizza name:

                                                EXECUTE_FUNCTION: search_pizza_price("pizza_name_here")

                                                For example:
                                                - If user asks "What's the price of \"pepperoni\" pizza?", 
                                                call "EXECUTE_FUNCTION: search_pizza_price(\"pepperoni\")"""
                                                                            </pre>
                                                                        </details>
                                                                        <!-- 
                                                                        <div class="vulnerability-explanation">
                                                                            <h4>Why This Is Critically Insecure - SQL Injection Risk:</h4>
                                                                            <ul>
                                                                                <li><strong>SQL Injection:</strong> The model can inject malicious SQL through text-based function calls</li>
                                                                                <li><strong>Text-Based Function Execution:</strong> The model controls function parameters through generated text</li>
                                                                                <li><strong>Direct String Concatenation:</strong> SQL queries built with unsafe string concatenation</li>
                                                                                <li><strong>No Input Validation:</strong> Function parameters from LLM are used directly in SQL queries</li>
                                                                                <li><strong>Database Error Exposure:</strong> SQL errors are returned to users, leaking system information</li>
                                                                                <li><strong>Pattern Matching:</strong> Simple regex extraction allows malicious payloads to pass through</li>
                                                                            </ul>
                                                                            
                                                                        <h4>Some SQL Injection Attack Patterns:</h4>
                                                                            <div class="attack-examples">
                                                                                <p><strong>Basic data extraction:</strong></p>
                                                                                <code>"What's the price of a pizza' UNION SELECT name, price FROM pizza --"</code>
                                                                                
                                                                                <p><strong>Extract customer comments:</strong></p>
                                                                                <code>"How much is a pizza' UNION SELECT name, content FROM comment --"</code>
                                                                                
                                                                                <p><strong>Database schema discovery:</strong></p>
                                                                                <code>"Price for pizza' UNION SELECT name, sql FROM sqlite_master --"</code>
                                                                            </div> -->
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            <!-- OpenAI Tab Content -->
                                                            <div class="tab-content" id="openai-model-tab">
                                                                <div class="model-implementation-section">
                                                                    <!-- OpenAI Status Section -->
                                                                    <div class="token-section openai-token-section">
                                                                        <h3>OpenAI API Status</h3>
                                                                        <div id="openai-api-status" class="api-status disconnected">
                                                                            <i class="fas fa-circle-xmark"></i> Checking API key...
                                                                        </div>
                                                                        <p class="help-text">
                                                                            <small>Set up your OpenAI API key in the <a href="{{ url_for('basics') }}">Lab Setup</a> section to use this feature.</small>
                                                                        </p>
                                                                    </div>
                                                                    
                                                                    <!-- OpenAI Chat Interface -->
                                                                    
                                                                    
                                                                    <div class="chat-container">
                                                                        <div id="openai-chat-messages" class="chat-messages">
                                                                           
                                                                        </div>
                                                                        <div class="chat-input">
                                                                            <input type="text" id="openai-user-message" placeholder="Ask about pizza prices...">
                                                                            <button id="openai-send-message">Send</button>
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    <!-- OpenAI Vulnerability Explanation -->
                                                                    <div class="security-vulnerability">
                                                                        <h3><i class="fas"></i> OpenAI API Function/Tool Calling with SQL Injection</h3>
                                                                        <p>This implementation uses OpenAI's function calling feature but creates a critical SQL injection vulnerability, you can view the code here:</p>
                                                                        
                                                                        <details class="code-dropdown">
                                                                            <summary class="code-dropdown-title">View Vulnerable Code</summary>
                                                                            <pre class="code-snippet">import json
                                        import sqlite3
                                        from openai import OpenAI

                                        def get_pizza_price(pizza_type):
                                            """
                                            VULNERABLE: Get the price for a specific pizza type using raw SQL query
                                            This function is intentionally vulnerable to SQL injection attacks
                                            """
                                            try:
                                                # Connect to the database
                                                conn = sqlite3.connect('application/instance/database.db')
                                                cursor = conn.cursor()
                                                <span style="color: red;">
                                                # VULNERABLE: Direct string concatenation in SQL query
                                                pizza = pizza_type.lower().replace("pizza", "")
                                                
                                                
                                                query = f"SELECT name, price FROM pizza WHERE LOWER(name) LIKE '%{pizza}%'"
                                                
                                                cursor.execute(query)
                                                result = cursor.fetchone()
                                                </span>
                                                if result:
                                                    name, price = result
                                                    return f"${price}"
                                                else:
                                                    return "Pizza not found in our menu"
                                                    
                                            except sqlite3.Error as e:
                                                return f"Database error: {str(e)}"  # Leaks error information
                                            finally:
                                                conn.close()

                                        # Function definition for OpenAI tools
                                        price_function = {
                                            "name": "get_pizza_price",
                                            "description": "Get the price for a specific pizza type.",
                                            "parameters": {
                                                "type": "object",
                                                "properties": {
                                                    "pizza_type": {
                                                        "type": "string",
                                                        "description": "The type of pizza you want to know the price for"
                                                    },
                                                },
                                                "required": ["pizza_type"],
                                            },
                                        }

                                        def chat_with_openai(user_input, api_key):
                                            
                                            client = OpenAI(api_key=api_key)
                                            
                                            # Call OpenAI API with tool/function calling
                                            response = client.chat.completions.create(
                                                model="gpt-3.5-turbo",
                                                messages=[
                                                    {"role": "system", "content": "You are a helpful pizza shop assistant."},
                                                    {"role": "user", "content": user_input},
                                                ],
                                                tools=[{
                                                    "type": "function",
                                                    "function": price_function
                                                }],
                                                tool_choice="auto"  # Let the model decide when to call the function
                                            )
                                            
                                            # Check if the model wants to call the function
                                            message = response.choices[0].message
                                            
                                            if message.tool_calls:
                                                for tool_call in message.tool_calls:
                                                    if tool_call.function.name == "get_pizza_price":
                                                        # Parse the function arguments
                                                        arguments = json.loads(tool_call.function.arguments)
                                                        pizza_type = arguments.get('pizza_type')
                                                        <span style="color: red;">
                                                        if pizza_type:
                                                            # VULNERABLE: No validation before executing function
                                                            price = get_pizza_price(pizza_type)
                                                        </span>    
                                                            # Get a response that includes the function result
                                                            second_response = client.chat.completions.create(
                                                                model="gpt-3.5-turbo",
                                                                messages=[
                                                                    {"role": "system", "content": "You are a helpful pizza shop assistant."},
                                                                    {"role": "user", "content": user_input},
                                                                    {"role": "assistant", "content": None, "tool_calls": [tool_call]},
                                                                    {"role": "tool", "tool_call_id": tool_call.id, 
                                                                    "content": f"The price for {pizza_type} pizza is {price}"}
                                                                ],
                                                            )
                                                            return second_response.choices[0].message.content
                                            
                                            # Return the original response if no function was called
                                            return message.content
                                    </pre>
                                </details>
                                <!--
                                <div class="vulnerability-explanation">
                                    <h4>Why This Is Critically Insecure - SQL Injection Risk:</h4>
                                    <ul>
                                        <li><strong>SQL Injection:</strong> The LLM can inject malicious SQL code through the pizza_type parameter</li>
                                        <li><strong>Direct String Concatenation:</strong> User input is directly inserted into SQL queries without parameterization</li>
                                        <li><strong>Database Access:</strong> The function has direct database access with no input validation</li>
                                        <li><strong>Error Information Leakage:</strong> Database errors are returned to the user, revealing system information</li>
                                        <li><strong>LLM Control:</strong> The AI model decides what parameters to pass to the vulnerable function</li>
                                        <li><strong>No Input Sanitization:</strong> No filtering or escaping of special SQL characters</li>
                                    </ul>
                                    
                                </div>-->
                            </div>
                        </div>
                    </div>
                             
                
                
                </section>
                </div>
            </details>
            
            <details class="description-dropdown">
                <summary class="dropdown-title">Mitigation Strategies</summary>
                <div class="dropdown-content">
                    <section class="section-box">
                        <div class="vulnerability-summary">
                    <h4>Common Security Issues in Both Implementations:</h4>
                    <ul>
                        <li>The LLM has complete control over which functions are called</li>
                        <li>The LLM decides what parameters are passed to the functions</li>
                        <li>A malicious prompt could trick the model into calling dangerous functions</li>
                        <li>There's no validation of function parameters before execution</li>
                        <li>There's no restriction on what functions can be called</li>
                        <li>The system blindly trusts the model's decisions without proper security checks</li>
                    </ul>
                </div>
                        <div class="security-tip">
                            <h3><i class="fas "></i> Secure Alternative</h3>
                            <p>A secure implementation would address both plugin security and SQL injection:</p>
                            <ul>
                                <li><strong>SQL Injection Prevention:</strong> Use parameterized queries instead of string concatenation</li>
                                <li><strong>Input Validation:</strong> Validate and sanitize all parameters before function execution</li>
                                <li><strong>Limited Database Access:</strong> Use ORM with proper access controls instead of raw SQL</li>
                                <li><strong>Plugin Sandboxing:</strong> Run plugins in isolated environments with restricted permissions</li>
                                <li><strong>Function Allowlisting:</strong> Use a limited set of pre-approved functions only</li>
                                <li><strong>Error Handling:</strong> Never expose database errors or internal system details to users</li>
                            </ul>
                            <p>Example of a secure implementation:</p>
                            <pre class="code-snippet"># SECURE: SQL Injection Prevention & Input Validation
import re
import sqlite3

# Whitelist of allowed pizza names
ALLOWED_PIZZAS = {'margherita', 'pepperoni', 'vegetarian', 'hawaiian', 'bbq chicken'}
SQL_KEYWORDS = ['union', 'select', 'drop', 'delete', 'insert', 'update', 'create', 'alter']

def get_pizza_price_secure(pizza_type):
    """Secure version with comprehensive protections"""
    
    # 1. Input validation
    if not isinstance(pizza_type, str) or len(pizza_type) > 50:
        return "Invalid input"
    
    pizza = pizza_type.lower().replace("pizza", "").strip()
    
    # 2. Block SQL injection keywords
    if any(keyword in pizza.lower() for keyword in SQL_KEYWORDS):
        return "Invalid characters detected"
    
    # 3. Character allowlist (alphanumeric + spaces only)
    if not re.match(r"^[a-zA-Z0-9\s]+$", pizza):
        return "Invalid characters in pizza name"
    
    # 4. Pizza name whitelist
    if not any(allowed in pizza for allowed in ALLOWED_PIZZAS):
        return "Pizza not available"
    
    try:
        conn = sqlite3.connect('application/instance/pizza_shop.db')
        cursor = conn.cursor()
        
        # 5. CRITICAL: Use parameterized query (prevents SQL injection)
        query = "SELECT name, price FROM pizza WHERE LOWER(name) LIKE ? LIMIT 1"
        cursor.execute(query, (f'%{pizza}%',))  # Safe parameter binding
        result = cursor.fetchone()
        
        if result:
            _, price = result
            return f"${price:.2f}"
        else:
            return "Pizza not found"
            
    except sqlite3.Error:
        # 6. Don't expose database errors
        return "Service temporarily unavailable"
    finally:
        if conn:
            conn.close()

# SECURE: Function allowlist with validation
ALLOWED_FUNCTIONS = {
    "get_pizza_price": get_pizza_price_secure
}

def secure_function_executor(function_name, params):
    """Secure function execution with validation"""
    # Only allow whitelisted functions
    if function_name not in ALLOWED_FUNCTIONS:
        return "Function not authorized"
    
    # Additional parameter validation
    if not params or len(params) > 50:
        return "Invalid parameters"
    
    return ALLOWED_FUNCTIONS[function_name](params)
</pre>
                        </div>
                    </section>
                </div>
            </details>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            
            // BlenderBot tab elements
            const userMessageInput = document.getElementById('user-message');
            const sendMessageButton = document.getElementById('send-message');
            const chatMessages = document.getElementById('chat-messages');
            
            // OpenAI tab elements
            const openaiApiStatus = document.getElementById('openai-api-status');
            const openaiUserMessageInput = document.getElementById('openai-user-message');
            const openaiSendMessageButton = document.getElementById('openai-send-message');
            const openaiChatMessages = document.getElementById('openai-chat-messages');
            
            // Cookie utility functions (INSECURE - storing API keys in cookies)
            function setCookie(name, value, days = 30) {
                const expires = new Date();
                expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
                document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
            }
            
            function getCookie(name) {
                const nameEQ = name + "=";
                const ca = document.cookie.split(';');
                for(let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                    if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
                }
                return null;
            }
            
            // Check for session-stored API key from basics page
            async function checkSessionApiKey() {
                console.log('Checking session API key...');
                try {
                    const response = await fetch('/check-openai-api-key');
                    const data = await response.json();
                    console.log('API key check result:', data);
                    
                    if (data.has_key) {
                        console.log('API key found in session, enabling OpenAI interface');
                        if (openaiApiStatus) {
                            openaiApiStatus.className = 'api-status connected';
                            openaiApiStatus.innerHTML = '<i class="fas fa-circle-check"></i> Connected to OpenAI API (from session)';
                        }
                        if (openaiUserMessageInput) {
                            openaiUserMessageInput.disabled = false;
                        }
                        if (openaiSendMessageButton) {
                            openaiSendMessageButton.disabled = false;
                        }
                        // Add welcome message if chat is empty
                        if (openaiChatMessages && openaiChatMessages.children.length <= 2) {
                            addBotMessage(openaiChatMessages, "API key detected from Lab Setup! I'm ready to help with pizza prices using OpenAI. You can ask questions like 'What's the price of a Pepperoni pizza?' or 'How much does a Margherita cost?'");
                        }
                    } else {
                        console.log('No API key found in session');
                        // No token found in session
                        if (openaiApiStatus) {
                            openaiApiStatus.className = 'api-status disconnected';
                            openaiApiStatus.innerHTML = '<i class="fas fa-circle-xmark"></i> No API key found - please set up in Lab Setup section';
                        }
                    }
                } catch (error) {
                    console.error('Error checking API key:', error);
                    if (openaiApiStatus) {
                        openaiApiStatus.className = 'api-status disconnected';
                        openaiApiStatus.innerHTML = '<i class="fas fa-circle-xmark"></i> Error checking API key';
                    }
                }
            }
            
            // Tab functionality for all tab groups
            function initializeTabs(headerSelector, contentPrefix) {
                const tabHeaders = document.querySelectorAll(headerSelector);
                
                tabHeaders.forEach(header => {
                    header.addEventListener('click', function() {
                        // Get all headers in this tab group (siblings)
                        const allHeaders = Array.from(this.parentElement.querySelectorAll(headerSelector));
                        
                        // Get all corresponding content tabs
                        const tabContents = allHeaders.map(h => 
                            document.getElementById(h.getAttribute('data-tab') + '-tab')
                        );
                        
                        // Remove active class from all tabs in this group
                        allHeaders.forEach(h => h.classList.remove('active'));
                        tabContents.forEach(c => c?.classList.remove('active'));
                        
                        // Add active class to clicked tab
                        this.classList.add('active');
                        const tabId = this.getAttribute('data-tab') + '-tab';
                        document.getElementById(tabId)?.classList.add('active');
                    });
                });
            }
            
            // Initialize all tab systems
            initializeTabs('.model-tabs .tab-header', '');
            initializeTabs('.chat-tabs .tab-header', '');
            
            // Initialize free chat interface (no API token needed)
            function initializeLlamaChat() {
                // Enable free chat interface immediately since no API token is needed
                if (userMessageInput && sendMessageButton) {
                    userMessageInput.disabled = false;
                    sendMessageButton.disabled = false;
                    
                    // Add welcome message
                    addBotMessage(chatMessages, "Welcome! I'm ready to help with pizza information using the local free model. You can ask questions like 'What's the price of a Pepperoni pizza?' or 'How much does a Margherita cost?'.");
                }
            }
            
            // Initialize LLaMA chat on page load
            initializeLlamaChat();
            
            // Session-based API key handling - no connect button needed
            
            // BlenderBot Send message button
            sendMessageButton.addEventListener('click', () => sendBlenderbotMessage());
            
            // BlenderBot Enter key
            userMessageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendBlenderbotMessage();
                }
            });
            
            // OpenAI Send message button
            openaiSendMessageButton.addEventListener('click', () => sendOpenAIMessage());
            
            // OpenAI Enter key
            openaiUserMessageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendOpenAIMessage();
                }
            });
            
            function sendBlenderbotMessage() {
                const userMessage = userMessageInput.value.trim();
                if (!userMessage) return;
                
                // Add user message to chat
                addUserMessage(chatMessages, userMessage);
                
                // Clear input
                userMessageInput.value = '';
                
                // Disable input while processing
                userMessageInput.disabled = true;
                sendMessageButton.disabled = true;
                
                // Show thinking indicator
                addBotMessage(chatMessages, '<i class="fas fa-spinner fa-spin"></i> Thinking...', 'thinking-message');
                
                // Send request to LLaMA model (no API token needed for local Ollama)
                fetch('/chat-with-pizza-assistant', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: userMessage,
                        api_token: null // No API token needed for local LLaMA model
                    })
                })
                .then(response => response.json())
                .then(data => {
                    // Remove thinking indicator
                    chatMessages.querySelector('.thinking-message')?.remove();
                    
                    // Add bot response
                    addBotMessage(chatMessages, data.response);
                    
                    // Re-enable input
                    userMessageInput.disabled = false;
                    sendMessageButton.disabled = false;
                    userMessageInput.focus();
                })
                .catch(error => {
                    // Remove thinking indicator
                    chatMessages.querySelector('.thinking-message')?.remove();
                    
                    // Show error message
                    addBotMessage(chatMessages, 'Sorry, there was an error processing your request. Please try again.');
                    console.error('Error:', error);
                    
                    // Re-enable input
                    userMessageInput.disabled = false;
                    sendMessageButton.disabled = false;
                });
            }
            
            function sendOpenAIMessage() {
                const userMessage = openaiUserMessageInput.value.trim();
                if (!userMessage) return;
                
                // Add user message to chat
                addUserMessage(openaiChatMessages, userMessage);
                
                // Clear input
                openaiUserMessageInput.value = '';
                
                // Disable input while processing
                openaiUserMessageInput.disabled = true;
                openaiSendMessageButton.disabled = true;
                
                // Show thinking indicator
                addBotMessage(openaiChatMessages, '<i class="fas fa-spinner fa-spin"></i> Thinking...', 'thinking-message');
                
                // Send request using session-stored OpenAI API key
                fetch('/chat-with-openai-plugin', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: userMessage
                        // API key now comes from session, not client-side
                    })
                })
                .then(response => response.json())
                .then(data => {
                    // Remove thinking indicator
                    openaiChatMessages.querySelector('.thinking-message')?.remove();
                    
                    // Add bot response
                    addBotMessage(openaiChatMessages, data.response);
                    
                    // Re-enable input
                    openaiUserMessageInput.disabled = false;
                    openaiSendMessageButton.disabled = false;
                    openaiUserMessageInput.focus();
                })
                .catch(error => {
                    // Remove thinking indicator
                    openaiChatMessages.querySelector('.thinking-message')?.remove();
                    
                    // Show error message
                    addBotMessage(openaiChatMessages, 'Sorry, there was an error processing your request. Please try again.');
                    console.error('Error:', error);
                    
                    // Re-enable input
                    openaiUserMessageInput.disabled = false;
                    openaiSendMessageButton.disabled = false;
                });
            }
            
            function addUserMessage(container, message) {
                const messageElement = document.createElement('div');
                messageElement.className = 'message user-message';
                messageElement.textContent = message;
                container.appendChild(messageElement);
                scrollToBottom(container);
            }
            
            function addBotMessage(container, message, extraClass = '') {
                const messageElement = document.createElement('div');
                messageElement.className = 'message bot-message ' + extraClass;
                messageElement.innerHTML = message;
                container.appendChild(messageElement);
                scrollToBottom(container);
            }
            
            function scrollToBottom(container) {
                container.scrollTop = container.scrollHeight;
            }
            
            // Check for session-stored API key on page load
            checkSessionApiKey();
        });
    </script>
</body>
</html>